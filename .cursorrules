Project Description: Nostr Hierarchical List Manager (Local-First Client)

Version: 1.2
Date: April 6, 2025

1. Introduction & Vision

Nostr's decentralized nature allows users to follow profiles and events, but managing large amounts of information can be challenging. NIP-51 provides a standard for lists, but lacks explicit hierarchical support.

This project aims to build a local-first, purely client-side web application that empowers Nostr users to create, manage, and browse hierarchical lists based on NIP-51. The application prioritizes storing your list data, related Nostr events (profiles, notes), and the hierarchy structure directly within your browser's local storage (IndexedDB). This ensures fast performance, enables reliable offline viewing of previously synchronized data, and reduces reliance on constant relay connectivity for core Browse functionality. Network interaction via NDK serves primarily to synchronize with the global Nostr network â€“ fetching new/updated events from relays and publishing the user's signed changes back out. User control and data ownership remain paramount.

2. Goals

    Provide an intuitive interface for creating and managing NIP-51 lists.
    Enable users to organize these lists hierarchically using stable 'a' tag references.
    Offer a clear and performant Tree View for Browse nested list structures.
    Operate entirely client-side, with no backend required beyond serving static files.
    Prioritize local data storage (IndexedDB) as the primary data source for the UI, enhancing performance and availability.
    Enable reliable offline Browse of previously synchronized lists, profiles, notes, and their hierarchical structure.
    Ensure data persistence and sharing through standard, signed Nostr events synchronized with user-configured relays.
    Deliver a modern, responsive, and fast UI/UX.

3. Target Audience (Users)

    (No change from previous version) Active Nostr users looking for better ways to organize... etc.

4. Core Features (MVP & Planned Scope)

    NIP-07 Integration: (No change)
    Relay Configuration: (No change)
    NIP-51 List Creation/Editing: (Specify local-first aspect)
        Support creating/editing NIP-51 Sets and Standard Lists, initially storing changes locally before attempting synchronization.
        Add/remove public items ('p', 'e') and hierarchical references ('a' to lists) locally first.
    Hierarchical Organization: (No change to mechanism - 'a' tags)
    Hierarchical Browse: (No change to UI goal)
    List Item Display: (No change - fetch details as needed, store locally)
    Local Persistence & Caching: All fetched/viewed lists, profiles, notes, and the computed hierarchy structure are stored robustly in IndexedDB.
    Synchronization (MVP: Read-only): Implement logic to fetch relevant new/updated NIP-51 list events (and associated profiles/notes) from configured relays via NDK and merge them into the local IndexedDB store based on timestamps/event properties.
    Offline Viewing: Browse already loaded/synchronized lists, profiles, notes, and navigate the hierarchy structure even when offline.
    (Post-MVP Scope):
        Publishing/Write Sync: Implement logic to queue locally created/modified lists, sign them via NIP-07 when online, publish them to relays via NDK, and handle potential conflicts (e.g., using last-write-wins based on created_at).
        Private List Items: Support NIP-04 encryption/decryption for private items, storing encrypted data locally and syncing.

5. Technical Stack

    Framework: SvelteKit
    Nostr Library: Nostr Dev Kit (NDK)
    Styling: Tailwind CSS (+ DaisyUI plugin)
    UI Toolkit: DaisyUI (via Tailwind plugin)
    State Management: Svelte Stores (built-in)
    Key Management: NIP-07 Browser Extensions (Primary method)
    Storage: Browser IndexedDB (Primary Local Store), Nostr Relays (Synchronization & Canonical Source)
    (Potential Future Consideration): CRDT library for more advanced conflict resolution if simple merging becomes insufficient.

6. Architecture Overview

    UI Layer: Svelte components rendering data primarily read from the Local Data Service. Styled with Tailwind/DaisyUI.
    Local Data Service (IndexedDB): Manages storing, retrieving, querying, and updating Nostr events (lists, profiles, notes) and computed hierarchy structures within IndexedDB. Acts as the main data source for the UI and state stores. Replaces the previous "Cache Service" concept.
    Hierarchy Service: Builds the nested tree structure from data retrieved via the Local Data Service. May store computed results back into IndexedDB for performance.
    NDK Service: Wrapper for the NDK instance, focused on communication with relays for synchronization purposes (fetching updates, publishing changes). Triggered by the Synchronization Logic.
    Synchronization Logic: Orchestrates the flow of data between the NDK Service (network) and the Local Data Service (local store). Fetches updates, compares data, triggers local updates, and (later) manages the outgoing publish queue.
    State Stores: Svelte stores holding readily accessible application state (e.g., login status, current hierarchy view derived from Local Data Service).

7. Key Implementation Details & Challenges

    Hierarchical Tree View: (No change - custom component needed).
    NIP-51 Compliance: (No change - use 'a' tags for lists).
    Hierarchy Logic: (No change - builds tree, handles cycles/depth). Now reads primarily from Local Data Service.
    Data Persistence & Sync: The application must treat IndexedDB as the primary source for UI rendering. All viewed/relevant data needs local persistence. The synchronization logic needs to efficiently query relays for updates since the last sync (potentially using since filters) and intelligently merge data (using created_at for replaceables, potentially more complex logic for list item additions/removals later). Initial focus is on read sync (updating local from network). Write sync (local to network) adds significant complexity around queuing, signing, publishing, and conflict handling.
    Offline Capability: Core Browse must function using only data present in IndexedDB. UI elements triggering network actions (e.g., "Refresh from Relays", "Publish Changes") should be disabled or provide appropriate feedback when offline.
    IndexedDB Performance: Efficient querying and indexing within IndexedDB will be important as data grows.
    NIP-07 Flow: (No change).

8. Getting Started (Initial Setup)

    (No major change, but emphasis shifts to setting up IndexedDB service early).

9. Future Considerations (Post-MVP)

    Implement robust Write Sync (Queuing, Publishing, Conflict Resolution).
    Implement Private List Item support (NIP-04).
    Real-time updates via NDK subscriptions (updating IndexedDB, then UI).
    More sophisticated sync strategies (background sync?).
    Data backup/export options from IndexedDB.
    Consider CRDTs if complex collaborative editing or multi-device sync without conflicts is desired.